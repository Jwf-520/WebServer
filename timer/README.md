
定时器处理非活动连接
===============
由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务。
我们有一个定时器结点类util，每个结点表示一个客户连接，它保存了双向链表的前后指针，客户数据client_data和回调函数。如果我们判断到这个结点长时间无反应，所以我们调用这个回调函数传入client_data，然后回调函数就会把这个客户断开，并且做一些善后工作。
链表类sort_timer_lst，这个链表是一个时间递增的结点链表，即从链表头到尾这个客户的最后一次反应时间是递增的。这个链表类当然有插入和删除结点函数。并且还有adjust_timer调整链表位置函数，作用是当一个客户有了反应，那么我们需要更新他的最后一次反应时间，那么为了维护链表的递增特性，我们需要这么一个调整位置的函数。此外，这个类还有一个检查函数(定时清扫)，作用是我们上文提到统一了事件源，把信号回调函数逻辑搬到主函数执行，所以这个定时清扫检查逻辑就是在这个检查函数。主函数判断到信号来了，就执行这个函数进行检查链表中长时间无反应的结点进行清扫。
> * 统一事件源
> * 基于时间堆的定时器
> * 处理非活动连接
时间堆定时器：
将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数 tick() 被调用，超时时间最小的定时器必然到期， 我们就可以在 tick()函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。
定时器具体执行过程：
（1） 首先使用socketpair创建管道。
（2） 设置写端为非阻塞，是为了减少信号处理的时间，即使定时事件失效也没关系，并不严格。
（3） 设置读端为ET非阻塞，向epoll树上挂读管道事件。
（4） 执行信号函数addsig，把信号添加到信号集当中，并把信号默认处理方式改成sig_handler函数(函数内容是向管道写入信号值)
（5） 设置bool值timeout和stop_server，后面需要使用他们判断是否执行信号对应的处理逻辑。
（6） 开始alarm函数，设定时间。
（7） 监听文件描述符epoll_wait。
（8） 监听到以后读出信号。
（9） 执行处理逻辑，如果信号是SIGALRM，timeout=true;如果是SIGTERM（ctrl+c）stop_server=true;
（10） 在server.eventloop（）（就是epoll树上监听到事件后的处理函数）中如果timeout==true,执行time_handler函数。
（11） time_handler函数(Util类中的)，首先执行tick()函数（定时器链表类中的），然后再次执行alarm()，相当于再次开始定时，一个alarm函数只能触发一次信号;
（12） tick()函数首先遍历定时器链表，找到到期的定时器（判断现在时间是否>expire，expire是定时器节点类中设定的超时时间），就是每过一段时间检查是否超时。即利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.
（13） 如果超时了就执行cb_func函数，删除epoll树上对应的通信fd，关闭通信fd,http_conn连接数-1；
（14） 项目中TIMESLOT值为5，expire初始值设置为 现有时间+3*TIMESLOT，每有读写事件发生，该通信fd对应的expire就加3个TIMESLOT，同时调整定时器链表类中该节点的位置，通过util类对象使用adjust_timer函数。